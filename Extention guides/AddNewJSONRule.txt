Created by Arthur Woodlee on 2/10/2025.

Adding a New Validation Rule

The validation system uses a modular, rule-based architecture. Each rule is self-contained and plugs into the shared BaseJSONValidator, which is instantiated in DataSetManager.swift.

1. Define Your Rule

Create a new struct that conforms to the ValidationRule protocol. Each rule must implement:
- description: A short summary of the rule
- matches(_ objects: [[String: Any]]): Logic to detect if the rule applies
- parse(...): Logic to transform the raw objects into a typed dataset

Example:

This guide walks you through how a new JSON validation rule that accepts objects with:

- A `"category"` string
- Four numeric fields
- One additional string field

Step 1: Define the Rule

Create a new struct conforming to `ValidationRule`:

struct Rule4NumericFieldsPlus1String: ValidationRule {
    var description: String { "category + 4 numeric fields + 1 extra string â†’ 6 keys" }

    func matches(_ objects: [[String: Any]]) -> Bool {
        objects.allSatisfy { obj in
            guard let category = obj["category"] as? String else { return false }

            let numericCount = obj.filter {
                $0.key != "category" && DecimalUtils.coerceDecimal(from: $0.value) != nil
            }.count

            let stringExtras = obj.filter {
                $0.key != "category" && DecimalUtils.coerceDecimal(from: $0.value) == nil && $0.value is String
            }

            return numericCount == 4 && stringExtras.count == 1 && obj.count == 6
        }
    }

    func parse(_ objects: [[String: Any]], name: String, description: String) -> Result<ValidatedDataSet, JSONValidationError> {
        let parsed: [DataPointStringDecimal_4Plus1] = objects.compactMap { obj in
            guard let category = obj["category"] as? String else { return nil }

            let numericValues = obj.filter {
                $0.key != "category" && DecimalUtils.coerceDecimal(from: $0.value) != nil
            }.compactMap { DecimalUtils.coerceDecimal(from: $0.value) }

            guard numericValues.count == 4 else { return nil }

            let extraString = obj.filter {
                $0.key != "category" && DecimalUtils.coerceDecimal(from: $0.value) == nil && $0.value is String
            }.first?.value as? String

            guard let extra = extraString else { return nil }

            return DataPointStringDecimal_4Plus1(
                category: category,
                value1: numericValues[0],
                value2: numericValues[1],
                value3: numericValues[2],
                value4: numericValues[3],
                extra: extra
            )
        }

        let dataSet = DataSetStringDecimal_4Plus1(name: name, description: description, data: parsed)
        return .success(.dataSetStringDecimal_4Plus1(dataSet))
    }
}
Step 2: Add Supporting Models

struct DataPointStringDecimal_4Plus1 {
    let category: String
    let value1: Decimal
    let value2: Decimal
    let value3: Decimal
    let value4: Decimal
    let extra: String
}

struct DataSetStringDecimal_4Plus1 {
    let name: String
    let description: String
    let data: [DataPointStringDecimal_4Plus1]
}

Step 3: Update the Enum

Extend `ValidatedDataSet` to include the new case:

case dataSetStringDecimal_4Plus1(DataSetStringDecimal_4Plus1)

Step 4: Register the Rule in DataSetManager

Update the validator inside `DataSetManager`:

private let validator = BaseJSONValidator(rules: [
    Rule2NumericFields(),
    Rule3NumericFields(),
    Rule4NumericFields(),
    Rule4NumericFieldsPlus1String()
])

This ensures the rule is applied during `storeJSON(_:)` and any future validation workflows.

