
//
//  Add ExtendDataInputSystem.html
//  AR3D_Augmented_Reality_Graphing
//
//  Created by Arthur Woodlee on 2/10/2025.
//
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Adding a New Validation Rule</title>
</head>
<body>

    <h2>Adding a New Validation Rule</h2>

    <p>The validation system uses a modular, rule-based architecture. Each rule is self-contained and plugs into the shared <code>BaseJSONValidator</code>, which is instantiated in <strong>DataSetManager.swift</strong>.</p>

    <h3>1. Define Your Rule</h3>

    <p>Create a new struct that conforms to the <code>ValidationRule</code> protocol. Each rule must implement:</p>

    <ul>
        <li><code>description</code>: A short summary of the rule</li>
        <li><code>matches(_ objects: [[String: Any]])</code>: Logic to detect if the rule applies</li>
        <li><code>parse(...)</code>: Logic to transform the raw objects into a typed dataset</li>
    </ul>

    <pre><code>struct RuleXNumericFields: ValidationRule {
    var description: String { "category + X numeric fields → Y keys" }

    func matches(_ objects: [[String: Any]]) -> Bool {
        objects.allSatisfy {
            $0.filter { $0.key != "category" && DecimalUtils.coerceDecimal(from: $0.value) != nil }.count == X
            && $0.count == Y
        }
    }

    func parse(_ objects: [[String: Any]], name: String, description: String) -> Result&lt;ValidatedDataSet, JSONValidationError&gt; {
        let parsed: [DataPointStringDecimal_X] = objects.compactMap { obj in
            guard let category = obj["category"] as? String else { return nil }
            let decimals = obj.filter { $0.key != "category" }
                              .compactMap { DecimalUtils.coerceDecimal(from: $0.value) }
            guard decimals.count == X else { return nil }
            return DataPointStringDecimal_X(category: category, value1: ..., valueX: ...)
        }

        let dataSet = DataSetStringDecimal_X(name: name, description: description, data: parsed)
        return .success(.dataSetStringDecimal_X(dataSet))
    }
}
    </code></pre>

    <h3>2. Add Supporting Types</h3>

    <p>Ensure the following types exist in your model layer:</p>

    <ul>
        <li><code>DataPointStringDecimal_X</code>: Struct with <code>category</code> and X <code>Decimal</code> fields</li>
        <li><code>DataSetStringDecimal_X</code>: Struct with <code>id</code>, <code>name</code>, <code>description</code>, and an array of <code>DataPointStringDecimal_X</code></li>
        <li>Add a new case to <code>ValidatedDataSet</code> enum: <code>.dataSetStringDecimal_X(DataSetStringDecimal_X)</code></li>
    </ul>

    <h3>3. Register the Rule in <code>DataSetManager</code></h3>

    <p>Open <strong>DataSetManager.swift</strong> and locate the <code>validator</code> property. This is where all rules are registered:</p>

    <pre><code>private let validator = BaseJSONValidator(rules: [
    Rule2NumericFields(),
    Rule3NumericFields(),
    Rule4NumericFields(),
    RuleXNumericFields()  <!-- Add your new rule here -->
])
    </code></pre>

    <p>This validator is used in:</p>

    <ul>
        <li><code>generateSyntheticDataset(...)</code> — to validate generated data</li>
        <li><code>storeJSON(...)</code> — to validate downloaded or imported data</li>
    </ul>

    <h3>4. (Optional) Extend Formatting Logic</h3>

    <p>If your rule introduces a new structure, update <code>GraphingDataUtils.formatExample(...)</code> to reflect it:</p>

    <pre><code>switch validated {
    case .dataSetStringDecimal_X:
        return "(String, Number, ..., Number)"  <!-- X numeric fields -->
}
    </code></pre>

    <h3>Done!</h3>
    <p>Your rule is now active and will be automatically evaluated during validation. No changes to the base validator logic are required.</p>

</body>
</html>
